<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>Hands On : ELK</title>

    <!-- Bootstrap -->
    <link href="css/bootstrap.min.css" rel="stylesheet">

		<!-- home made custom CSS -->
    <link href="css/tuto.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>
  <body>

    <div class="container">

      <div>
        <h1> Hands On : LogStash, ElasticSearch, Kibana, et plus encore </h1>
        <p class="lead">Ce tutoriel détaillera pas à pas : 
					<ul>
						<li>L'installation locale de LogStash, ElasticSearch et Kibana</li>
						<li>Le traitement de fichiers de logs par LogStash</li>
						<li>L'indexation dans ElasticSearch</li>
						<li>Le requêtage via Kibana</li>
						<li>Et pour aller plus loin : l'utilisation d'un broker de messages et d'agents distants, la mise en cluster d'ElasticSearch, des éléments sur le tuning de performances d'ElasticSearch, ...</li>
					</ul>
				</p>
				<div class="alert alert-warning" role="alert">
					Dans le but d'éviter les incidents de démarrage lors de l'atelier, merci de suivre la partie "Pré-requis et installation" avant l'atelier, depuis un ordinateur connecté à Internet !
				</div>
				<div>
					<ul>
						<li><a href="#install">Pré-requis et installation</a></li>
						<li><a href="#logstash">Etape 1 : LogStash</a></li>
						<li><a href="#es">Etape 2 : ElasticSearch</a></li>
						<li><a href="#kibana">Etape 3 : Kibana</a></li>
						<li><a href="#further">Pour aller plus loin...</a>
							<ul>
								<li><a href="#rspec">Tests unitaires de LogStash</a>
								<li><a href="#broker">Utilisation d'un agent et d'un broker de messages</a>
								<li><a href="#cluster">Clustering</a>
								<li><a href="#perf">Eléments de performances</a>
							</ul>
						</li>
					</ul>
				</div>
      </div>

      <div>
				<h2 id="install">Pré-requis et installation</h2>
L'utilisation de la machine virtuelle demande au minimum un ordinateur avec un CPU puissant (type Intel Core i5), <strong>8Go de RAM</strong>, et un système d'exploitation (Windows, Mac ou Linux) <strong>64 bits</strong>. Si votre machine ne dispose pas de ce hardware minimum, merci d'installer avant le début de l'atelier les logiciels indiqués plus bas, dans la section <a href="#novm">Sans machine virtuelle</a> plus bas.

					<h3>Utilisation de la machine virtuelle fournie</h3>
					<div class="alert alert-danger" role="alert">
						TODO
					</div>
 
					<h3 id="novm">Sans machine virtuelle</h3>
Pour tous les logiciels qui ne seront pas installés sous forme de package, nous allons placer les binaires dans un même dossier. Tous les chemins seront relatifs à ce dossier, par exemple pour Linux : <code>/home/cvillard/elk</code>. Il y sera fait référence via la variable : <code>$MY_DIR</code>.
							<h4>Java 8</h4>
<p><strong>Linux (Ubuntu)</strong></p>
<p>
Contrôler la version de Java installée : 
<pre>
$ java -version
openjdk version "1.8.0_66-internal"
OpenJDK Runtime Environment (build 1.8.0_66-internal-b17)
OpenJDK 64-Bit Server VM (build 25.66-b17, mixed mode)
</pre>
Si la version est inférieure à 1.8 ou si la commande est inconnue, installer l'openJDK 8 :
<pre>
$ sudo aptitude install openjdk-8-jdk
</pre>
Vérifier que l'installation s'est bien passée en reprenant la commande de vérification.
</p>
<p><strong>Windows</strong></p>
							<div class="alert alert-danger" role="alert">
								TODO
							</div>

							<h4>LogStash</h4>
<p>Nous utiliserons la dernière version de LogStash : 2.1.0. </p>
<p>Télécharger le ZIP ou le TAR.GZ de la version 2.1.0 à cette adresse : <a href="https://www.elastic.co/downloads/logstash">https://www.elastic.co/downloads/logstash</a>.</p>
<p>Décompresser l'archive dans <code>$MY_DIR</code>. </p>
<p>Tester que LogStash se lance bien avec la commande : 
<pre>
$ ${MY_DIR}/logstash-2.1.0/bin/logstash version
logstash 2.1.0
</pre>
</p>

							<h4>ElasticSearch</h4>
<p>Nous utiliserons la dernière version d'ElasticSearch : 2.1.0. </p>
<p>Télécharger le ZIP ou le TAR de la version 2.1.0 à cette adresse : <a href="https://www.elastic.co/downloads/elasticsearch">https://www.elastic.co/downloads/elasticsearch</a>.</p> 
<p>Décompresser l'archive dans <code>$MY_DIR</code>.</p> 
<p>Tester qu'ElasticSearch se lance bien avec la commande : 
<pre>
$ ./elasticsearch-2.1.0/bin/elasticsearch
</pre>
Une fois la trace suivante reçue dans la console (<code>Kirigi</code> étant le nom du noeud, il change à chaque démarrage) : 
<pre>
[2015-11-28 14:03:28,178][INFO ][node                     ] [Kirigi] started
</pre>
Contrôler à l'URL <a href="http://localhost:9200/">http://localhost:9200/</a> qu'il répond :
<pre>
{
  "name" : "Kirigi",
  "cluster_name" : "elasticsearch",
  "version" : {
    "number" : "2.1.0",
    "build_hash" : "72cd1f1a3eee09505e036106146dc1949dc5dc87",
    "build_timestamp" : "2015-11-18T22:40:03Z",
    "build_snapshot" : false,
    "lucene_version" : "5.3.1"
  },
  "tagline" : "You Know, for Search"
}
</pre>
</p>

							<h4>Kibana</h4>
<p>La version de Kibana compatible avec ElasticSearch 2.1.x est la version 4.3.0. </p>
<p>Télécharger la version comaptible avec votre système à l'adresse: <a href="https://www.elastic.co/downloads/kibana">https://www.elastic.co/downloads/kibana</a>. </p>
<p>Décompresser l'archive dans <code>$MY_DIR</code>. </p>
<p>Lancer Kibana avec la commande :
<pre>
$ ./kibana-4.3.0-linux-x64/bin/kibana
</pre>
Une fois la trace suivante obtenue dans la console :
<pre>
  log   [14:11:46.405] [info][listening] Server running at http://0.0.0.0:5601
</pre>
Vérifier que Kibana répond à l'URL <a href="http://localhost:5601/">http://localhost:5601/</a>. On ne va rien configurer pour l'instant, cela fera partie de la suite du tutoriel.
</p>

							<h4>RabbitMQ</h4>
<p>Erlang est nécessaire au fonctionnement de RabbitMQ.
</p>
<p><strong>Windows</strong></p>
<p>
Télécharger le package Erlang pour Windows 64 bits à l'adresse : <a href="http://www.erlang.org/download.html">http://www.erlang.org/download.html</a>.
</p>
<p>Exécuter l'installeur pour Windows en conservant les options par défaut. </p>

<p>Télécharger l'installeur Windows à l'adresse <a href="https://www.rabbitmq.com/download.html">https://www.rabbitmq.com/download.html</a>. 
</p>
<p>Exécuter l'installeur pour Windows en conservant les options par défaut. </p>

<p><strong>Linux</strong></p>

<p>Pour Ubuntu, installer le package fourni dans les dépots, il contient toutes les dépendances nécessaires :
<pre>
$ sudo aptitude install rabbitmq-server
</pre>
L'installation du paquet déclenche le démarrage du serveur. Contrôler cela via la commande :
<pre>
$ sudo rabbitmqctl status
Status of node 'rabbit@claire-i5' ...
[{pid,16510},
 {running_applications,[{rabbit,"RabbitMQ","3.5.4"},
                        {mnesia,"MNESIA  CXC 138 12","4.13"},
                        {os_mon,"CPO  CXC 138 46","2.4"},
                        {xmerl,"XML parser","1.3.8"},
                        {sasl,"SASL  CXC 138 11","2.5"},
                        {stdlib,"ERTS  CXC 138 10","2.5"},
                        {kernel,"ERTS  CXC 138 10","4.0"}]},
 {os,{unix,linux}},
 {erlang_version,"Erlang/OTP 18 [erts-7.0] [source] [64-bit] [smp:4:4] [async-threads:64] [kernel-poll:true]\n"},
 {memory,[{total,42831280},
          {connection_readers,0},
          {connection_writers,0},
          {connection_channels,0},
          {connection_other,2712},
          {queue_procs,2712},
          {queue_slave_procs,0},
          {plugins,0},
          {other_proc,13403656},
          {mnesia,61024},
          {mgmt_db,0},
          {msg_index,46816},
          {other_ets,761048},
          {binary,13248},
          {code,16907095},
          {atom,654217},
          {other_system,10978752}]},
 {alarms,[]},
 {listeners,[{clustering,25672,"::"},{amqp,5672,"::"}]},
 {vm_memory_high_watermark,0.4},
 {vm_memory_limit,3341025280},
 {disk_free_limit,50000000},
 {disk_free,51512127488},
 {file_descriptors,[{total_limit,65436},
                    {total_used,3},
                    {sockets_limit,58890},
                    {sockets_used,1}]},
 {processes,[{limit,1048576},{used,126}]},
 {run_queue,0},
 {uptime,248}]

</pre>
</p>
<p>Pour les autres distributions, se reporter à la <a href="https://www.rabbitmq.com/download.html">documentation de l'outil</a> (peut nécessiter de compiler Erlang).
</p>
	
      </div>

			<div>
				<h2 id="logstash">Etape 1 : LogStash</h2>
<p>
Dans cette étape, nous allons lire un fichier de logs avec LogStash, découper ces logs pour leur ajouter de la sémantique, et les faire écrire dans la sortie standard. 
</p>
<p>
Pour commencer, nous allons avoir besoin de logs à lire. Pour cela, enregistrer dans <code>$MY_DIR</code> <a href="./files/logstash-tutorial-small.log">ce fichier</a>.
</p>
<p>
Créer ensuite dans <code>$MY_DIR</code> un fichier nommé <code>logstash.conf</code>. L'éditer avec l'éditeur de texte de votre choix, et y placer le code suivant en remplaçant <code>$MY_DIR</code> par sa valeur (par exemple <code>/home/cvillard/elk</code>) :
<pre>
# C'est un commentaire
input {
	# On définit ici les sources de données à traiter
	file {
		path => "$MY_DIR/logstash-tutorial-small.log"
		start_position => beginning 
	}
}

output {
	# on définit ici les destinations pour les données traitées
	stdout {
		# Sortie standard : pas de paramètres
	}
}

</pre>
</p>
<p>
Démarrer LogStash en lui indiquant le fichier de configuration : 
<pre>
$ ./logstash-2.1.0/bin/logstash agent -f './logstash.conf'
Settings: Default filter workers: 2
Logstash startup completed
2015-11-28T15:34:10.995Z claire-i5 83.149.9.216 - - [04/Jan/2015:05:13:42 +0000] "GET /presentations/logstash-monitorama-2013/images/kibana-search.png HTTP/1.1" 200 203023 "http://semicomplete.com/presentations/logstash-monitorama-2013/" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/32.0.1700.77 Safari/537.36"
</pre>
Vous devriez voir s'afficher dans la console le contenu du fichier, la ligne étant précédée d'un timestamp et du nom de votre PC ajoutés automatiquement par LogStash (<code>2015-11-28T15:34:10.995Z claire-i5</code> dans mon exemple).
</p>
<p>
Interrompre LogStash avec <code>Ctrl+C</code> : 
<pre>
^CSIGINT received. Shutting down the pipeline. {:level=>:warn}
Logstash shutdown completed
</pre>
</p>	

<p>
Nous avons donc lu un fichier avec LogStash et l'avons recopié sur la sortie standard. C'est un bon début, mais ce n'est pas suffisant. Nous allons maintenant modifier la configuration pour découper chaque ligne lue dans le fichier en un message JSON contenant des champs nommé. Cela permettra d'ajouter de la sémantique à chaque ligne, et ensuite de faire des recherches une fois dans ElasticSearch.
</p>

				<div class="alert alert-info" role="alert">
<p>
Pour éviter de relire des lignes déjà lues en cas de redémarrage de LogStash, celui-ci stocke sur le disque l'endroit où il se trouve dans les fichiers qu'il lit. Par défaut, il crée des fichiers <code>.sincedb_*</code> dans le <code>$HOME</code> de l'utilisateur qui le lance. 
</p>
<p>
Ainsi, pour faire relire à LogStash un fichier déjà lu, il faut enlever la ligne contenant l'inode de ce fichier dans le fichier <code>.sincedb_*</code> correspondant (ou supprimer le fichier entier).
</p>
<p>
Il est également possible de paramétrer l'endroit où LogStash écrit ses informations et le nom du fichier correspondant pour éviter de polluer le dossier home et rendre le nom plus explicite que <code>.sincedb_1bd0462c651e913184f7efa9f40f84c6</code> :
<pre>
input {
	# On définit ici les sources de données à traiter
	file {
		path => "$MY_DIR/logstash-tutorial-small.log"
		start_position => beginning 
		# on customise le sincedb_path et le nom du fichier
		sincedb_path => "/var/log/logstash/sincedb_apache.log"
	}
}
</pre>
</p>
				</div>
<p>
LogStash embarque des patterns pour traiter un grand nombre de formats de logs courants. C'est le cas pour les logs Apache traités ici.
</p>
<p>
Ouvrir le fichier <code>logstash.conf</code> créé précédemment et ajouter le bloc suivant entre le bloc <code>input</code> et le bloc <code>output</code> :
<pre>
filter {
	grok {
		match => { "message" => "%{COMBINEDAPACHELOG}"}
	}
}
</pre>
De plus, on va modifier l'output <code>stdout</code> pour qu'il écrive le message complet en JSON au lieu de le résumer : 
<pre>
output {
	# on définit ici les destinations pour les données traitées
	stdout {
		codec => json
	}
}
</pre>
</p>
<p>
N'oubliez pas de supprimer le fichier <code>.sincedb_*</code> puis redémarrez LogStash avec la même commande que précédemment.
<pre>
$ ./logstash-2.1.0/bin/logstash agent -f './logstash.conf'
Settings: Default filter workers: 2
Logstash startup completed
{"message":"83.149.9.216 - - [04/Jan/2015:05:13:42 +0000] \"GET /presentations/logstash-monitorama-2013/images/kibana-search.png HTTP/1.1\" 200 203023 \"http://semicomplete.com/presentations/logstash-monitorama-2013/\" \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/32.0.1700.77 Safari/537.36\"","@version":"1","@timestamp":"2015-11-28T16:10:15.811Z","host":"claire-i5","path":"/home/claire/Documents/atelier_es_mydir/logstash-tutorial-small.log","clientip":"83.149.9.216","ident":"-","auth":"-","timestamp":"04/Jan/2015:05:13:42 +0000","verb":"GET","request":"/presentations/logstash-monitorama-2013/images/kibana-search.png","httpversion":"1.1","response":"200","bytes":"203023","referrer":"\"http://semicomplete.com/presentations/logstash-monitorama-2013/\"","agent":"\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/32.0.1700.77 Safari/537.36\""}
^CSIGINT received. Shutting down the pipeline. {:level=>:warn}
Logstash shutdown completed
</pre>
</p>
<p>
Une fois mis en forme, on voit que la ligne de log a maintenant la forme suivante :
<pre>
{
	"message":"83.149.9.216 - - [04/Jan/2015:05:13:42 +0000] \"GET /presentations/logstash-monitorama-2013/images/kibana-search.png HTTP/1.1\" 200 203023 \"http://semicomplete.com/presentations/logstash-monitorama-2013/\" \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/32.0.1700.77 Safari/537.36\"",
	"@version":"1",
	"@timestamp":"2015-11-28T16:10:15.811Z",
	"host":"claire-i5",
	"path":"/home/claire/Documents/atelier_es_mydir/logstash-tutorial-small.log",
	"clientip":"83.149.9.216",
	"ident":"-",
	"auth":"-",
	"timestamp":"04/Jan/2015:05:13:42 +0000",
	"verb":"GET",
	"request":"/presentations/logstash-monitorama-2013/images/kibana-search.png",
	"httpversion":"1.1",
	"response":"200",
	"bytes":"203023",
	"referrer":"\"http://semicomplete.com/presentations/logstash-monitorama-2013/\"",
	"agent":"\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/32.0.1700.77 Safari/537.36\""
}
</pre>
Les différentes partie du log d'origine ont été découpées et placées dans des champs nommés. La ligne d'origine est elle conservée en l'état dans le champ <code>message</code>.
</p>

				<div class="alert alert-info" role="alert">
<p>
<strong>Qu'avons-nous fait ?</strong>
</p>
<p>
En ajoutant ce filtre, nous avons utilisé GROK. C'est un outil utilisant une syntaxe pouvant s'apparenter aux expressions régulières, et qui dans LogStash permet de découper un champ (<code>message</code> dans notre cas) en plusieurs champs nommés.
</p>
<p>
Par exemple, le pattern prédéfini que nous avons utilisé est défini par la syntaxe suivante :
<pre>
COMBINEDAPACHELOG %{COMMONAPACHELOG} %{QS:referrer} %{QS:agent}
</pre>
On voit qu'il fait lui-même référence à d'autres patterns : <code>COMMONAPACHELOG</code> et <code>QS</code>. La configuration complète donne : 
<pre>
WORD \b\w+\b
NOTSPACE \S+
BASE10NUM (?&lt;![0-9.+-])(?&gt;[+-]?(?:(?:[0-9]+(?:\.[0-9]+)?)|(?:\.[0-9]+)))
NUMBER (?:%{BASE10NUM})
INT (?:[+-]?(?:[0-9]+))
DATA .*?

MONTHDAY (?:(?:0[1-9])|(?:[12][0-9])|(?:3[01])|[1-9])
MONTH \b(?:Jan(?:uary)?|Feb(?:ruary)?|Mar(?:ch)?|Apr(?:il)?|May|Jun(?:e)?|Jul(?:y)?|Aug(?:ust)?|Sep(?:tember)?|Oct(?:ober)?|Nov(?:ember)?|Dec(?:ember)?)\b
YEAR (?&gt;\d\d){1,2}

HOUR (?:2[0123]|[01]?[0-9])
MINUTE (?:[0-5][0-9])
# '60' is a leap second in most time standards and thus is valid.
SECOND (?:(?:[0-5][0-9]|60)(?:[:.,][0-9]+)?)
TIME (?!&lt;[0-9])%{HOUR}:%{MINUTE}(?::%{SECOND})(?![0-9])

IPV6 ((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?
IPV4 (?&lt;![0-9])(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))(?![0-9])
IP (?:%{IPV6}|%{IPV4})
HOSTNAME \b(?:[0-9A-Za-z][0-9A-Za-z-]{0,62})(?:\.(?:[0-9A-Za-z][0-9A-Za-z-]{0,62}))*(\.?|\b)

IPORHOST (?:%{HOSTNAME}|%{IP})
USERNAME [a-zA-Z0-9._-]+
USER %{USERNAME}
HTTPDATE %{MONTHDAY}/%{MONTH}/%{YEAR}:%{TIME} %{INT}

COMMONAPACHELOG %{IPORHOST:clientip} %{USER:ident} %{USER:auth} \[%{HTTPDATE:timestamp}\] "(?:%{WORD:verb} %{NOTSPACE:request}(?: HTTP/%{NUMBER:httpversion})?|%{DATA:rawrequest})" %{NUMBER:response} (?:%{NUMBER:bytes}|-)

QUOTEDSTRING (?&gt;(?&lt;!\\)(?&gt;"(?&gt;\\.|[^\\"]+)+"|""|(?&gt;'(?&gt;\\.|[^\\']+)+')|''|(?&gt;`(?&gt;\\.|[^\\`]+)+`)|``))
# QS n'est qu'un alias
QS %{QUOTEDSTRING}

COMBINEDAPACHELOG %{COMMONAPACHELOG} %{QS:referrer} %{QS:agent}
</pre>
On est plutôt contents de ne pas avoir eu à l'écrire nous-même, et on comprend également pourquoi GROK est généralement, dans une configuration LogStash, le plus gros consommateur de temps d'exécution. Les améliorations de performances devront avant tout se porter sur l'optimisation des expressions GROK au cas d'usage.
</p>
<p>
La mise au point d'un pattern GROK "maison" (non embarqué par défaut), pour traiter un format de log non standard, peut donc s'avérer ardue. Pour aider à sa mise au point, il existe un outil en ligne très pratique : <a href="http://grokdebug.herokuapp.com/">Grok Debugger</a>. Il liste également <a href="http://grokdebug.herokuapp.com/patterns">l'ensemble des patterns embarqués dans LogStash</a>.
</p>
				</div>

				<div class="alert alert-warning" role="alert">
<p>
L'extrait de configuration GROK mentionné au dessus contient la ligne suivante pour désigner le mois dans la date :
<pre>
MONTH \b(?:Jan(?:uary)?|Feb(?:ruary)?|Mar(?:ch)?|Apr(?:il)?|May|Jun(?:e)?|Jul(?:y)?|Aug(?:ust)?|Sep(?:tember)?|Oct(?:ober)?|Nov(?:ember)?|Dec(?:ember)?)\b
</pre>
On voit que les noms de mois sont en dur, et en anglais. On ne supporte que la version complète et la version abrégée. 
</p>
<p>
De plus, le pattern de date <code>"dd/MMM/YYYY:HH:mm:ss Z"</code> utilisé juste après dans ce tutoriel dépend de la locale de la machine ou de celle précisée en paramètre du filtre <code>date</code>. 
</p>
<p>
C'est pour ces 2 raisons qu'il faut éviter autant que possible les patterns de date contenant du texte pour les jours et les mois, au profit de leur écriture en chiffre qui elle n'est pas dépendante de la locale et n'est pas ambigüe.
</p>
				</div>

<p>
L'ajout de sémantique à notre log a donc plutôt bien fonctionné. Il reste néanmoins une dernière anomalie au niveau du champ <code>@timestamp</code>. En effet, celui-ci est ajouté automatiquement par LogStash, et renseigné avec l'heure du moment où il a lu la ligne dans le fichier. Dans un cas comme ici où on relis des logs anciens, cette date n'a aucun intérêt : la date intéressante est celle contenue dans le log lui-même, soit le 4 janvier 2015 à 05:13:42 dans notre cas, et qui a été placée dans le champ <code>timestamp</code> (sans <code>@</code>) par le pattern GROK <code>COMBINEDAPACHELOG</code>. Nous allons donc utiliser le filtre <code>date</code> pour lire la valeur String du champ <code>timestamp</code> (sans <code>@</code>), la transformer en timestamp et la placer dans le champ <code>@timestamp</code> (avec <code>@</code>) en remplacement de la valeur automatique.
</p>
<p>
Pour cela, ouvrir le fichier <code>logstash.conf</code>, et ajouter un filtre après le GROK :
<pre>
filter {
	grok {
		match => { "message" => "%{COMBINEDAPACHELOG}"}
	}
	date {
		# exemple de date: 04/Jan/2015:05:13:42 +0000
		match => [ "timestamp", "dd/MMM/YYYY:HH:mm:ss Z" ] 
	}
}
</pre>
</p>
<p>
N'oubliez pas de supprimer le fichier <code>.sincedb_*</code> puis redémarrez LogStash avec la même commande que précédemment.
<pre>
$ ./logstash-2.1.0/bin/logstash agent -f './logstash.conf'
Settings: Default filter workers: 2
Logstash startup completed
{"message":"83.149.9.216 - - [04/Jan/2015:05:13:42 +0000] \"GET /presentations/logstash-monitorama-2013/images/kibana-search.png HTTP/1.1\" 200 203023 \"http://semicomplete.com/presentations/logstash-monitorama-2013/\" \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/32.0.1700.77 Safari/537.36\"","@version":"1","@timestamp":"2015-01-04T05:13:42.000Z","host":"claire-i5","path":"/home/claire/Documents/atelier_es_mydir/logstash-tutorial-small.log","clientip":"83.149.9.216","ident":"-","auth":"-","timestamp":"04/Jan/2015:05:13:42 +0000","verb":"GET","request":"/presentations/logstash-monitorama-2013/images/kibana-search.png","httpversion":"1.1","response":"200","bytes":"203023","referrer":"\"http://semicomplete.com/presentations/logstash-monitorama-2013/\"","agent":"\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/32.0.1700.77 Safari/537.36\""}
^CSIGINT received. Shutting down the pipeline. {:level=>:warn}
Logstash shutdown completed
</pre>
</p>
<p>
Si on compare les champs <code>@timestamp</code> et <code>timestamp</code> dans la sortie on a maintenant les valeurs suivantes :
<pre>
	"@timestamp":"2015-01-04T05:13:42.000Z",
	"timestamp":"04/Jan/2015:05:13:42 +0000",
</pre>

Les deux valeurs sont bien identiques, on pourra donc une fois dans ElasticSearch faire une recherche sur le champ standard <code>@timestamp</code> et avoir des résultats pertinents...
</p>

      </div>

			<div>
				<h2 id="es">Etape 2 : ElasticSearch</h2>
Dans cette étape, nous allons utiliser le résultat de l'étape précédente pour indexer les logs découpés dans ElasticSearch et les rechercher sommairement via l'API REST d'ElasticSearch. Nous apprendrons également comme configurer sommairement ElasticSearch et comment le monitorer avec quelques plugins courants.

				<div class="alert alert-danger" role="alert">
					TODO
				</div>
				
      </div>

			<div>
				<h2 id="kibana">Etape 3 : Kibana</h2>
Dans cette étape, nous allons voir comment Kibana permet de rechercher facilement dans ElasticSearch, et nous créerons un dashboard.

				<div class="alert alert-danger" role="alert">
					TODO
				</div>

				<div class="alert alert-success" role="alert">Vous voilà arrivés à la fin du tutoriel. Vous pouvez continuer à lire pour aller plus loin...</div>
      </div>



			<div>
				<h2 id="further">Pour aller plus loin...</h2>
Nous avons vu une infrastructure simple d'exploitation de logs. Elle souffre de nombreux points faibles : goulets d'étranglements de performances, vulnérabilité aux pannes, impact sur la charge des machines monitorées... Ces points peuvent être résolus par l'ajout de nouvelles briques et l'utilisation de clusters.

				<h3 id="rspec">Tests unitaires de LogStash</h3>
<p>
L'écriture d'une configuration LogStash peut être très complexe : patterns GROK, utilisation de conditions sur des champs pour appliquer des opérations particulières, transformations de valeurs de champs... 
</p>
<p>
Pour fiabiliser cela, LogStash fourni un outil de tests unitaires, qui permet de contrôler qu'une entrée a bien été transformée comme prévu...
</p>

				<div class="alert alert-danger" role="alert">
					TODO
				</div>

				
				<h3 id="broker">Utilisation d'un agent et d'un broker de messages</h3>

<p>Deux problèmes principaux sont présents dans l'architecture telle que mise en place dans ce tutoriel : le traitement des messages avec Grok peut être très gourmand en CPU, et le fait de pousser directement dans ElasticSearch implique un couplage fort entre les deux briques. 
</p>
<p>Ces deux points peuvent être problématiques en production : La charge induite par LogStash peut perturber les applications supervisées, et toute indisponibilité d'ElasticSearch peut impacter le fonctionnement de l'agent.
</p>
<p>Pour résoudre cela, il est préférable d'installer LogStash sur les machines supervisées avec une configuration minimale, qui ne fait que lire les fichiers de logs, gérer le multiligne si nécessaire, et pousser les messages dans la suite de l'infrastructure, elle située sur des machines dédiées. Le traitement poussé des messages (Grok notamment) sera réalisé par une ou plusieurs autres instances de LogStash (voir le paragraphe "Clustering" plus loin) sur ces machines dédiées, et se chargera de pousser dans ElasticSearch.
</p>
<p>
Pour communiquer entre le LogStash "agent" installé sur les machines clientes et le LogStash "serveur" réalisant les traitements, il faut insérer entre eux deux une brique intermédiaire de "broker de messages". Plusieurs technologies peuvent être utilisées pour cela : Redis, RabbitMQ, Apache Kafka... Chacune de ces solutions ont leurs avantages et leurs inconvénients, à adapter à chaque cas d'usage. RabbitMQ offrant une bonne simplicité de mise en oeuvre et une interface d'administration pratiques dans le cadre de ce tutoriel, c'est ce que nous allons utiliser.
</p>
<div class="alert alert-info" role="alert">Dans le cadre de ce tutoriel, il est possible de démarrer 2 fois LogStash sur votre PC en même temps, en précisant 2 fichiers de configuration différents pour la partie "agent" et la partie "serveur".</div>
</div>
<div class="alert alert-info" role="alert">Voici un extrait de la documentation de RabbitMQ sur les concepts spécifiques à RabbitMQ d'exchange, de queue et de routage dans RabbitMQ : 
				<div class="alert alert-danger" role="alert">
					TODO
				</div>
</div>

<p>
Dans cette partie, vous pouvez donc :
<ol>
<li>Démarrer un serveur RabbitMQ sur votre poste via la commande <code>$MY_DIR/rabbitmq_server-3.5.6/sbin/rabbitmq-server -detached</code> 
</li>
<li>Configurer un exchange, une queue et un routage dans RabbitMQ (voir plus haut l'explication de ces concepts) :
				<div class="alert alert-danger" role="alert">
					TODO
				</div>
</li>
<li>Séparer le fichier <code>logstash.conf</code> en 2 parties. La première jouera le rôle de l'agent, et contiendra la lecture du fichier de logs et la dépose dans RabbitMQ. La seconde jouera le rôle du serveur, et lira les messages depuis RabbitMQ et les déposer dans ElasticSearch comme précédemment.
</li>
<li>Démarrer les 2 instances de LogStash.
</li>
<li>Constater sur les logs arrivent dans ElasticSearch tout comme avant.
</li>
</ol>

L'état de RabbitMQ et des queues qu'il contient peut être consulté sur l'IHM d'administration (notez le <code>s</code> à <code>https</code>) : <a href="https://localhost:15671/">https://localhost:15671/</a>

</p>


				<h3 id="cluster">Clustering</h3>
<p>
Telle qu'elle, l'application n'est pas tolérante aux pannes : si ElasticSearch s'arrête, toute la chaine devient indisponible. Pour un usage en production, la haute disponibilité, la tolérance aux pannes et la montée en charge par du scaling horizontal peuvent être nécessaires.
</p>
<p>
Comme nous l'avons vu, il est très facile de démarrer plusieurs instances de LogStash. Ainsi, il serait très facile d'installer LogStash sur 2 ou plus de machines, avec un fichier de configuration identique leur faisant lire la même file RabbitMQ et déposer dans le même ElasticSearch, pour dupliquer cette partie de l'infrastructure.
</p>
<p>
Réaliser la même chose au niveau d'ElasticSearch n'est guère plus complexe : il suffit de démarrer un second noeud avec le même nom de cluster que le premier et d'indiquer le premier noeud dans la liste des noeuds du cluster pour que le cluster se forme. En gardant la configuration par défaut qui crée 1 réplique de toutes les données et la répartition automatique des données entre les noeuds implémentée dans ElasticSearch, la haute disponibilité est à l'oeuvre...
</p>
<p>
Dans cette partie, vous pouvez donc :
<ol>
<li>Dupliquer le fichier de configuration <code>elasticsearch.yml</code>, et modifier les ports d'écoute pour pouvoir le lancer sur la même machine que le premier noeud.
<div class="alert alert-danger" role="alert">
					TODO
				</div>
</li>
<li>Configurer dans ce même fichier le premier noeud comme autre membre du cluster pour qu'ils se découvrent :
				<div class="alert alert-danger" role="alert">
					TODO
				</div>
</li>
<li>Démarrer ce second noeud avec le nouveau fichier de configuration, et observer le résultat dans l'IHM Head d'ElasticSearch, sur le premier ou le second noeud (les mêmes données sont affichées) : <a href="https://localhost:9200/">https://localhost:9200/</a>
</li>
</ol>
</p>

<div class="alert alert-info" role="alert">Pour éviter les points uniques de défaillance (SPOF, Single Point of Failure) si à l'étape précédente on a mis en place RabbitMQ entre un LogStash agent et un serveur, il faudra également le mettre en cluster. Cela sort du cadre de ce Hands on, mais toute la documentation est disponible <a href="https://www.rabbitmq.com/clustering.html">sur le site du produit</a>.
</div>

				<h3 id="perf">Eléments de performances</h3>
				<div class="alert alert-danger" role="alert">
					TODO
				</div>
<div class="alert alert-success" role="alert">Vous voilà à la toute fin du tutoriel cette fois-ci... Have fun avec ELK ;)</div>

      </div>

    </div><!-- /.container -->

		<footer class="footer" role="contentinfo">
      <div class="container">
        <ul class="footer-links text-center">
					<li><a href="http://www.duchess-france.org/"><img src="images/duchess.jpg" heigth="32px" width="32px" /></a></li>
      		<li>&middot;</li>
					<li><a href="https://twitter.com/leneurone_eu"><img src="images/twitter.png" /></a></li>
      		<li>&middot;</li>
					<li><a href="https://github.com/leneurone/atelier-duchess-elk"><img src="images/github.png" /></a></li>
				</ul>
      </div>
    </footer> <!-- footer -->


    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
    <script src="../../dist/js/bootstrap.min.js"></script>
    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    <script src="../../assets/js/ie10-viewport-bug-workaround.js"></script>
  </body>
</html>
